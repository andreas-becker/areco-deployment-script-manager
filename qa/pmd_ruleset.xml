<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="hybris_extensions"
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
  <description>Custom Rule set for Hybris proyects</description>
  
  <rule ref="category/java/bestpractices.xml"> <!-- These rules are common sense -->
	  <exclude name="GuardLogStatement"/> <!-- Guarding is only reuired when the calculation of string takes resources -->	   
	  <exclude name="ConstantsInInterface" /> <!-- I prefer to use an interface than an abstract class for constants -->
	  <!-- PreserveStackTrace: The stacktrace must be logged -->
  </rule>
  
    
  <rule ref="category/java/codestyle.xml" > <!-- It is consistent with the code conventions and improves readibility -->
	  <exclude name="AvoidFinalLocalVariable"/> <!-- There isn't any wrong in final local variables -->
  </rule>
  
  <!-- Good practices to avoid imperative programming. The limits require tweaking. -->
  <rule ref="category/java/design.xml" >
	  <exclude name="ModifiedCyclomaticComplexity"/> <!-- One rule to measure the cyclomatic complexity is enough. -->
	  <exclude name="StdCyclomaticComplexity"/> <!-- One rule to measure the cyclomatic complexity is enough. -->
  </rule>
  
  <!-- Comments ruleset. The next one is the only useful rule. -->
  <rule ref="category/java/documentation.xml/CommentRequired" >
	<!-- UncommentedEmptyMethodBody: Always document empty blocks -->
	<!-- Only the interface of a classshould have comments -->
	<properties>
		<property name="enumCommentRequirement" value="Ignored" />
		<property name="protectedMethodCommentRequirement" value="Ignored" />
		<property name="publicMethodCommentRequirement" value="Required" />
		<property name="fieldCommentRequirement" value="Ignored" />
		<property name="headerCommentRequirement" value="Required" />
		<!-- We ignore the rule for setters and getters -->
		<property name="violationSuppressRegex" value="(is|get|set).*"/>
		<!-- We ignore overidden public methods, constructors and methods with the annotations @Test, @Before or @After -->
		<property name="violationSuppressXPath" value="//ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Public='true' and ../Annotation/MarkerAnnotation/Name[@Image= 'Override' or @Image= 'Test' or @Image= 'After' or @Image= 'Before']] | //ClassOrInterfaceBodyDeclaration/ConstructorDeclaration" />
	</properties>
  </rule>
  
  <rule ref="category/java/errorprone.xml" >
	  <!-- Good practices with the clone method -->
  </rule>  
  
  <rule ref="category/java/multithreading.xml"> 
	<!-- AvoidUsingVolatile: I don't really understand volatile and Java's memory model, and you? -->	
	<exclude name="AvoidSynchronizedAtMethodLevel"/> <!-- The synchronized at method level is easier to understand -->
  </rule>
  
  <rule ref="category/java/performance.xml"> 	  
  </rule>
  
  <rule ref="category/java/security.xml"> 	  
  </rule>
  
  
  <!-- JavaBean: Most of the classes are never serialized and defining the serialID is only more work for the developer. -->
   
</ruleset>
